import { __extends } from "tslib";
import * as _ from '@antv/util';
import Base from './base';
import extended, { ALL_Q } from './util/extended';
var Linear = /** @class */ (function (_super) {
    __extends(Linear, _super);
    function Linear() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Linear.prototype.scale = function (_value) {
        if (_.isNil(_value)) {
            return NaN;
        }
        var max = this._transform(this.max);
        var min = this._transform(this.min);
        if (min === max) {
            // https://github.com/d3/d3-scale/blob/master/src/continuous.js normalize
            return 0.5;
        }
        // min <= value <= max
        var value = Math.min(Math.max(this._transform(_value), min), max);
        var percent = this._calcPercent(value, min, max);
        var range0 = _.head(this.range);
        var range1 = _.last(this.range);
        return this._calcValue(percent, range0, range1);
    };
    Linear.prototype.invert = function (scaled) {
        var range0 = _.head(this.range);
        var range1 = _.last(this.range);
        var max = this._transform(this.max);
        var min = this._transform(this.min);
        var percent = this._calcPercent(scaled, range0, range1);
        return this._calcValue(percent, min, max);
    };
    Linear.prototype._initDefaultCfg = function () {
        this.values = [];
        this.type = 'linear';
        this.isLinear = true;
        this.nice = true;
        this.tickCount = 5;
        this.maxTickCount = 10;
    };
    Linear.prototype._init = function () {
        this._setDomain();
        if (_.isEmpty(this.ticks)) {
            this.ticks = this._setTicks();
        }
    };
    Linear.prototype._setDomain = function () {
        var _a = _.getRange(this.values), min = _a.min, max = _a.max;
        if (_.isNil(this.min)) {
            this.min = min;
        }
        if (_.isNil(this.max)) {
            this.max = max;
        }
        if (this.min > this.max) {
            console.error('min should less than max');
            this.min = min;
            this.max = max;
        }
    };
    Linear.prototype._transform = function (v) {
        return v;
    };
    Linear.prototype._setTicks = function () {
        var _a, _b;
        var _this = this;
        var _c = this._getAlgoParams(), onlyLoose = _c.onlyLoose, Q = _c.Q, w = _c.w, m = _c.m;
        var adjustTicks = [];
        var tickCnt = m;
        var minLimit = this.minLimit;
        var maxLimit = this.maxLimit;
        var tickMin;
        var tickMax;
        // minLimit/maxLimit相同情况处理
        if (!_.isNil(minLimit) && !_.isNil(maxLimit) && minLimit === maxLimit) {
            console.error('minLimit should less than maxLimit');
            minLimit = minLimit / 2;
            if (minLimit === 0) {
                maxLimit = 1;
            }
        }
        tickMin = _.isNil(minLimit) ? this.min : this.minLimit;
        tickMax = _.isNil(maxLimit) ? this.max : this.maxLimit;
        // 最终的min/max校验和处理
        if (tickMin > tickMax) {
            console.error('minLimit should less than maxLimit');
            _a = [tickMax, tickMin], tickMin = _a[0], tickMax = _a[1];
            _b = [maxLimit, minLimit], minLimit = _b[0], maxLimit = _b[1];
        }
        do {
            var _d = extended(tickMin, tickMax, tickCnt, onlyLoose, Q, w), min = _d.min, max = _d.max, ticks = _d.ticks;
            adjustTicks = [];
            if (this.nice) {
                this.min = min;
                this.max = max;
            }
            // 修正min/max
            if (!_.isNil(minLimit)) {
                this.min = minLimit;
            }
            if (!_.isNil(maxLimit)) {
                this.max = maxLimit;
            }
            adjustTicks.push(this.min);
            _.each(ticks, function (tick) {
                if (tick > _this.min && tick < _this.max) {
                    adjustTicks.push(tick);
                }
            });
            if (adjustTicks[adjustTicks.length - 1] < this.max) {
                adjustTicks.push(this.max);
            }
            // 如果没有设置 minLimit/maxLimit，就不循环
            if (_.isNil(minLimit) && _.isNil(maxLimit)) {
                break;
            }
            // 效果是否已经很好了
            if (ticks.indexOf(this.min) >= 0 && ticks.indexOf(this.max) >= 0) {
                break;
            }
            tickCnt += 1;
        } while (tickCnt < this.maxTickCount);
        return adjustTicks;
    };
    Linear.prototype._getAlgoParams = function () {
        var _a = this.algoParam || {}, onlyLoose = _a.onlyLoose, _Q = _a.Q, w = _a.w;
        var Q = _Q;
        var m = this.tickCount;
        if (this.minTickInterval) {
            var interval = Math.abs(this.minTickInterval);
            var e = Math.floor(Math.log10(interval));
            // interval转为 (0, 10) 之间的值
            var i_1 = interval / Math.pow(10, e);
            Q = ALL_Q.filter(function (n) { return n >= i_1; });
            if (!_.includes(Q, i_1)) {
                Q.push(i_1);
            }
            // tickCount也需要相应调整
            m = Math.ceil((this.max - this.min) / this.minTickInterval) + 1;
            // nice numbers数组长度不能<2
            if (Q.length === 1) {
                Q.push(1);
            }
        }
        return {
            m: m,
            w: w,
            Q: Q,
            onlyLoose: onlyLoose,
        };
    };
    return Linear;
}(Base));
export default Linear;
//# sourceMappingURL=linear.js.map