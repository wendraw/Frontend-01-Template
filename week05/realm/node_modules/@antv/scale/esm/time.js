import { __extends } from "tslib";
import * as _ from '@antv/util';
import * as moment from 'moment';
import Base from './base';
import bisector from './util/bisector';
import pretty from './util/pretty';
var SECOND = 1000;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var Time = /** @class */ (function (_super) {
    __extends(Time, _super);
    function Time() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** 将定义域转化为时间戳 */
    Time.prototype.translate = function (v) {
        return moment(v).valueOf();
    };
    Time.prototype.scale = function (_value) {
        var min = this.min;
        var max = this.max;
        var value = Math.min(Math.max(this.translate(_value), min), max);
        var percent = this._calcPercent(value, min, max);
        var range0 = _.head(this.range);
        var range1 = _.last(this.range);
        return this._calcValue(percent, range0, range1);
    };
    Time.prototype.invert = function (scaled) {
        var range0 = _.head(this.range);
        var range1 = _.last(this.range);
        var min = this.min;
        var max = this.max;
        var percent = this._calcPercent(scaled, range0, range1);
        return moment(this._calcValue(percent, min, max)).startOf('s');
    };
    Time.prototype._initDefaultCfg = function () {
        this.type = 'time';
        this.values = [];
        this.tickCount = 10;
    };
    Time.prototype._init = function () {
        var _this = this;
        this.values = _.map(this.values, function (date) { return _this.translate(date); });
        this._setDomain();
        if (_.isEmpty(this.ticks)) {
            if (this.tickInterval) {
                this.ticks = this._setTicksByInterval();
            }
            else if (this.tickCount) {
                this.ticks = this._setTicks();
            }
        }
    };
    Time.prototype._setDomain = function () {
        if (_.isNil(this.min)) {
            this.min = _.minBy(this.values, function (v) { return v; });
        }
        else {
            this.min = this.translate(this.min);
        }
        if (_.isNil(this.max)) {
            this.max = _.maxBy(this.values, function (v) { return v; });
        }
        else {
            this.max = this.translate(this.max);
        }
    };
    /**
     * todo: 自创算法，融合了d3和pretty，需要大量测例验证
     */
    Time.prototype._setTicks = function () {
        var _this = this;
        /**
         * 思路：
         * step1: 通过d3的算法找到日期大致范围
         * step2: 通过pretty取得系数为1、0.5、2
         */
        var intervals = [
            ['HH:mm:ss', SECOND],
            ['HH:mm:ss', SECOND * 10],
            ['HH:mm:ss', SECOND * 30],
            ['HH:mm', MINUTE],
            ['HH:mm', MINUTE * 10],
            ['HH:mm', MINUTE * 30],
            ['HH', HOUR],
            ['HH', HOUR * 6],
            ['HH', HOUR * 12],
            ['YYYY-MM-DD', DAY],
            ['YYYY-MM-DD', DAY * 4],
            ['YYYY-WW', DAY * 7],
            ['YYYY-MM', DAY * 31],
            ['YYYY-MM', DAY * 31 * 4],
            ['YYYY-MM', DAY * 31 * 6],
            ['YYYY', DAY * 380],
        ];
        var tickCount = this.tickCount;
        var minDate = this.min;
        var maxDate = this.max;
        var target = (maxDate - minDate) / tickCount;
        var idx = bisector(function (o) { return o[1]; })(intervals, target);
        if (idx === intervals.length) {
            // over 1Y
            this.interval = _.last(intervals);
        }
        else if (idx) {
            this.interval = intervals[idx];
        }
        else {
            // 避免pretty取0.5，可以在此处加一个最大值边界
            // 此处的Math.min是没有意义的（为什么？），此处保留只是因为可能会调整算法，这个是安全保障
            tickCount = Math.min(Math.floor((maxDate - minDate) / SECOND), tickCount);
            this.interval = intervals[0];
        }
        var d = this.interval[1];
        var ticks = pretty(0, Math.ceil((maxDate - minDate) / d), tickCount).ticks;
        // time的tick不能取超出定义域的值
        var res = ticks.map(function (tick) { return tick * d + minDate; }).filter(function (tick) { return tick >= minDate && tick <= maxDate; });
        if (this.showLast) {
            // 间隔大于一个interval时需添加，pretty可以避免这种场景
            res[res.length - 1] = this.max;
        }
        if (!this.formatter) {
            this.formatter = function (v) { return moment(v).format(_this.interval[0]); };
        }
        return res;
    };
    Time.prototype._setTicksByInterval = function () {
        var _this = this;
        var minDate = this.min;
        var maxDate = this.max;
        var d = this.tickInterval[1];
        var tickCount = Math.ceil((maxDate - minDate) / d);
        var ticks = [];
        for (var i = 0; i <= tickCount; i++) {
            var val = minDate + d * i;
            if (val > maxDate && this.showLast) {
                val = maxDate;
            }
            ticks.push(val);
        }
        var formatedTicks = [];
        _.each(ticks, function (tick) {
            formatedTicks.push(moment(tick).format(_this.tickInterval[0]));
        });
        return formatedTicks;
    };
    return Time;
}(Base));
export default Time;
//# sourceMappingURL=time.js.map